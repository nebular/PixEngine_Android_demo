#version 330 core

#define BLUR false
#define MAXSPRITES 32

precision highp float;


// texture sampler
uniform sampler2D glbuffer;
uniform sampler2D m7ground;
uniform sampler2D spritebuffer0, spritebuffer1, spritebuffer2, spritebuffer3, spritebuffer4, spritebuffer5,spritebuffer6,spritebuffer7;

out vec4 FragColor;

in vec3 ourColor;
in vec2 TexCoord;

uniform highp vec2  iResolution;			// sceen resolution in px
uniform highp vec3  iCamWorld;			// sceen resolution in px
uniform highp float iTime;					// sceen resolution in px
uniform highp int   iSpriteSheets;			// number of sprite sheets

// sheetwidth, sheetheight, numspr_x, numspr_y
uniform highp vec4 iSpriteSheet0, iSpriteSheet1, iSpriteSheet2, iSpriteSheet3, iSpriteSheet4, iSpriteSheet5, iSpriteSheet6, iSpriteSheet7, iSpriteSheet8;
// Sprite positions array
uniform highp vec4 iSpritePos0[MAXSPRITES], iSpritePos1[MAXSPRITES], iSpritePos2[MAXSPRITES], iSpritePos3[MAXSPRITES], iSpritePos4[MAXSPRITES], iSpritePos5[MAXSPRITES], iSpritePos6[MAXSPRITES], iSpritePos7[MAXSPRITES];
// Sprite status (on/off) array
uniform highp int  iSpriteDef0[MAXSPRITES], iSpriteDef1[MAXSPRITES], iSpriteDef2[MAXSPRITES], iSpriteDef3[MAXSPRITES], iSpriteDef4[MAXSPRITES], iSpriteDef5[MAXSPRITES], iSpriteDef6[MAXSPRITES], iSpriteDef7[MAXSPRITES];

// uniform highp vec2 iLightPosition;
// uniform highp vec2 iSkyColor;

vec2 iLightPosition=vec2(10,5);


// spritesheet: calulations




bool hasImage(int sprite) {
    return sprite != -1;
}

// generic 2d rotate
mat2 rotate2d(float _angle){
    return mat2(cos(_angle), -sin(_angle),
    sin(_angle), cos(_angle));
}

vec2 rotateDimensions(vec2 target, float angle) {
    target = rotate2d(angle) * target;
    target.x = abs(target.x);
    target.y = abs(target.y);
    return target;
}

vec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
    vec4 color = vec4(0.0);
    vec2 off1 = vec2(1.3333333333333333) * direction;
    color += texture(image, uv) * 0.29411764705882354;
    color += texture(image, uv + (off1 / resolution)) * 0.35294117647058826;
    color += texture(image, uv - (off1 / resolution)) * 0.35294117647058826;
    return color;
}

// imageVector: x,y,scale,rotation
vec4 drawImage(vec4 spriteSheet, vec2 uv, vec4 imageVector, sampler2D source, int spriteIndex, bool blur) {

	vec2 __spriteSize =  spriteSheet.xy/spriteSheet.zw;

    if (hasImage(spriteIndex)) {
		
		// x,y cell in spritesheet
		vec2 sprite = vec2(spriteIndex%int(spriteSheet.z), spriteIndex/int(spriteSheet.z));

		// offset in sprite sheet
		vec2 __spsheetoff = sprite*__spriteSize * imageVector.z;

        float t = 0.0;
        vec4 fincolor = vec4(0,0,0,0);

        vec2 pos = iResolution.xy * vec2(imageVector.xy) ;
        vec2 ssize = __spriteSize / iResolution.xy; // vec2(imageVector.zw);

        vec2 dimens = ssize * iResolution.xy * imageVector.z;
		float angle = imageVector.w;

		// rotate if needed
        if (angle != 0.) {

            // image rotation r/center
            uv -= vec2(pos.x, pos.y);

            // angle = abs(angle);
            uv = rotate2d(angle) *  uv;

            uv.y = 1. - uv.y;

            uv += vec2(pos.x, pos.y);
            dimens = rotateDimensions(dimens, angle);

        }

        if ((uv.x > pos.x - dimens.x / 2.0) && (uv.x < pos.x + dimens.x / 2.0)
        && (uv.y > pos.y - dimens.y / 2.0) && (uv.y < pos.y +  dimens.y / 2.0)) {

            // point belongs inside the rectangle: render the sprite

            t = 1.0;

            // DIMENS dimensiones del agujero con las dimensiones de la cara
            // image rescale factor "fit xy"
            // adjustaremos desde fuera xa q ese FITXY sea justo el tamano del bitmap
            // en lugar del tamano de la cara

            // position in texture
            vec2 textpos = vec2(uv.x-(pos.x - dimens.x / 2.0), uv.y-(pos.y -  dimens.y / 2.0));

			// add offset in sheet
			textpos += __spsheetoff;

			// divide by number of sprites
			textpos /= spriteSheet.zw;

			// final texture coordinates
            vec2 textcoord =  textpos / dimens;

			if (blur)
				fincolor = blur5(source, textcoord, __spriteSize.xy, normalize(vec2(1.,1.)));
			else
				fincolor = texture(source, textcoord);

        }

        return fincolor;

    } else return vec4(0, 0, 0, 0);

}

vec4 mixSprite(in vec4 spritesheet, in vec2 fragCoord, in vec4 imageVector, in sampler2D channel, in vec4 destinationLayer, in int sprite, bool blur) {

    if (hasImage(sprite)) {
    
        vec4 faceColor = drawImage(spritesheet, fragCoord, imageVector, channel, sprite, blur);
        return mix(destinationLayer, faceColor, faceColor.a);
        
    } else return destinationLayer;

}



float rnd(vec2 p)
{
    float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));
 return f;
}

float rnd(float w)
{
    float f = fract(sin(w)*1000.);
 return f;
}

float regShape(vec2 p, int N)
{
 float f;
    
    
float a=atan(p.x,p.y)+.2;
float b=6.28319/float(N);
f=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));
    
    
    return f;
}
vec3 circle(vec2 p, float size, float decay, vec3 color,vec3 color2, float dist, vec2 mouse)
{
 	 
    
    //l is used for making rings.I get the length and pass it through a sinwave
    //but I also use a pow function. pow function + sin function , from 0 and up, = a pulse, at least
    //if you return the max of that and 0.0.
    
    float l = length(p + mouse*(dist*4.))+size/2.;
    
    //l2 is used in the rings as well...somehow...
    float l2 = length(p + mouse*(dist*4.))+size/3.;
    
    ///these are circles, big, rings, and  tiny respectively
    float c = max(00.01-pow(length(p + mouse*dist), size*1.4), 0.0)*50.;
    float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*30.), 0.0)*3.;
    float c2 =  max(0.04/pow(length(p-mouse*dist/2. + 0.09)*1., 1.), 0.0)/20.;
    float s = max(00.01-pow(regShape(p*5. + mouse*dist*5. + 0.9, 6) , 1.), 0.0)*5.;
    
   	color = 0.5+0.5*sin(color);
    color = cos(vec3(0.44, .24, .2)*8. + dist*4.)*0.5+.5;
 	vec3 f = c*color ;
    f += c1*color;
    
    f += c2*color;
    f +=  s*color;
    return f-0.01;
}

float sun(vec2 p, vec2 mouse)
{
 float f;
    
    vec2 sunp = p+mouse;
    float sun = 1.0-length(sunp)*8.;
    return f;
}

vec3 mixsun(vec3 color) {

	vec2 uv = vec2(TexCoord.x, TexCoord.y) - 0.5;
	vec2 mm = vec2(iCamWorld.x, -0.4); // y  - 0.5;

	//get angle and length of the sun (uv - mouse)
	 float a = atan(uv.y-mm.y, uv.x-mm.x);
	 float l = max(1.0-length(uv-mm)-0.84, 0.0);
	 
	 float bright = 0.8;//+0.1/abs(sin(iTime/3.))/3.;//add brightness based on how the sun moves so that it is brightest
	 //when it is lined up with the center


	 //add the sun with the frill things
	 color += max(0.1/pow(length(uv-mm)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;
	 color += max(0.1/pow(length(uv-mm)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;
	 //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.
	 color += (max(bright/pow(length(uv-mm)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;
		// * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));
	//multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that
	//there is a sharper roll of of the light decay from the sun.
	color*= exp(1.0-length(uv-mm))/10.;
	return color;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord , vec3 color)
{
	vec2 uv = fragCoord.xy / iResolution.xy-0.5;
    //uv=uv*2.-1.0;
    uv.x*=iResolution.x/iResolution.y;
    
    vec2 mm = iLightPosition.xy/iResolution.xy - 0.5;
    mm.x *= iResolution.x/iResolution.y;
    
    if(true)
    {
		// mm = iCamWorld.xy  - 0.5;
		mm = vec2(iCamWorld.x, -0.4); // y  - 0.5;
//       mm = vec2(sin(iTime/6.)/1., 0.2 + cos(iTime/8.)/2. )/2.;
        
    }
    vec3 circColor = vec3(0.9, 0.2, 0.1);
    vec3 circColor2 = vec3(0.3, 0.1, 0.9);
    
    //now to make the sky not black
  // color = mix(vec3(0.3, 0.2, 0.02)/0.9, vec3(0.2, 0.5, 0.8), uv.y)*3.-0.52*sin(iTime);
    
    //this calls the function which adds three circle types every time through the loop based on parameters I
    //got by trying things out. rnd i*2000. and rnd i*20 are just to help randomize things more
	
	/*
    for(float i=0.;i<10.;i++){
        color += circle(uv, pow(rnd(i*2000.)*1.8, 2.)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, mm);
    }
    */

	color = mixsun(color);

	/*
    //get angle and length of the sun (uv - mouse)
    float a = atan(uv.y-mm.y, uv.x-mm.x);
  	float l = max(1.0-length(uv-mm)-0.84, 0.0);
    
    float bright = 0.8;//+0.1/abs(sin(iTime/3.))/3.;//add brightness based on how the sun moves so that it is brightest
    //when it is lined up with the center


    //add the sun with the frill things
    color += max(0.1/pow(length(uv-mm)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;
    color += max(0.1/pow(length(uv-mm)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;
    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.
    color += (max(bright/pow(length(uv-mm)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;
       // * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));



    //multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that
    //there is a sharper roll of of the light decay from the sun.
	color*= exp(1.0-length(uv-mm))/10.;
	*/
	fragColor = vec4(color,1.0) ; //* texture(iChannel1,fragCoord/iResolution.xy);
}


vec4 atmosColor(vec4 incolor, vec2 fragCoord) {
	vec4 fragColor = vec4(0,0,0,0);
	mainImage(fragColor, fragCoord, incolor.xyz);
	return fragColor;
//	return mix(incolor, fragColor, 0.8);
}

/**/


void main() {

	vec4 face = vec4(texture(m7ground, TexCoord).rgb, 1.0);
	vec2 fragCoord = vec2(TexCoord*iResolution.xy);
	face= atmosColor(face, fragCoord); // vec2(fragCoord.x, iResolution.y-fragCoord.y));


	if (iSpriteSheets>0)
		for (int i=0; i<MAXSPRITES; i++) face = mixSprite(iSpriteSheet0, fragCoord, iSpritePos0[i], spritebuffer0, face, iSpriteDef0[i], BLUR);
	else if (iSpriteSheets>1)
		for (int i=0; i<MAXSPRITES; i++) face = mixSprite(iSpriteSheet1, fragCoord, iSpritePos1[i], spritebuffer1, face, iSpriteDef1[i], BLUR);
	else if (iSpriteSheets>2)
		for (int i=0; i<MAXSPRITES; i++) face = mixSprite(iSpriteSheet2, fragCoord, iSpritePos2[i], spritebuffer2, face, iSpriteDef2[i], BLUR);
	else if (iSpriteSheets>3)
		for (int i=0; i<MAXSPRITES; i++) face = mixSprite(iSpriteSheet3, fragCoord, iSpritePos3[i], spritebuffer3, face, iSpriteDef3[i], BLUR);
	else if (iSpriteSheets>4)
		for (int i=0; i<MAXSPRITES; i++) face = mixSprite(iSpriteSheet4, fragCoord, iSpritePos4[i], spritebuffer4, face, iSpriteDef4[i], BLUR);
	else if (iSpriteSheets>5)
		for (int i=0; i<MAXSPRITES; i++) face = mixSprite(iSpriteSheet5, fragCoord, iSpritePos5[i], spritebuffer5, face, iSpriteDef5[i], BLUR);
	else if (iSpriteSheets>6)
		for (int i=0; i<MAXSPRITES; i++) face = mixSprite(iSpriteSheet6, fragCoord, iSpritePos6[i], spritebuffer6, face, iSpriteDef6[i], BLUR);
	else if (iSpriteSheets>7)
		for (int i=0; i<MAXSPRITES; i++) face = mixSprite(iSpriteSheet7, fragCoord, iSpritePos7[i], spritebuffer7, face, iSpriteDef7[i], BLUR);

	FragColor = face; // atmosColor(face, fragCoord); // vec2(fragCoord.x, iResolution.y-fragCoord.y));
//	FragColor = face;
}


